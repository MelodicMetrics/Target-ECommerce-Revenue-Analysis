<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orders_Final, Order_Items_Final, and Payments_Final Index</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/Target-ECommerce-Revenue-Analysis/assets/css/solarized-light.min.css">
    <link rel="stylesheet" href="/Target-ECommerce-Revenue-Analysis/assets/css/styles.css"> <!-- Custom styles last -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>


</head>
<body>
    <!-- Sticky Navbar -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand" href="/">Target E-Commerce Analysis</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                    <li class="nav-item">
                        <a class="nav-link" href="Target-ECommerce-Revenue-Analysis/index.md">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/data-cleaning/index.md/">Data Cleaning Part One</a>
                    <li class="nav-item">
                        <a class="nav-link" href="Target-ECommerce-Revenue-Analysis/data-cleaning-part-two/index.md">Data Cleaning Part Two</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="Target-ECommerce-Revenue-Analysis/EDA/index.md">Exploratory Data Analysis</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/revenue-analysis/">Revenue Analysis</a>
                    </li>
                </ul>
                <form class="d-flex" role="search">
                    <input class="form-control me-2" type="search" placeholder="Search" aria-label="Search">
                    <button class="btn btn-outline-success" type="submit">Search</button>
                </form>
            </div>
        </div>
    </nav>
       
   <!-- Breadcrumbs -->
<nav aria-label="breadcrumb" style="margin-top: 4rem;">
    <ol class="breadcrumb bg-light p-2">
        <!-- Home link -->
        <li class="breadcrumb-item"><a href="/">Home</a></li>

        <!-- Dynamic Breadcrumb Logic -->
        
        
        
        
            
            
                <!-- Intermediate folders (linked) -->
                <li class="breadcrumb-item">
                    <a href="/data-cleaning-part-two">Data cleaning part two</a>
                </li>
            
        
            
            
                <!-- Intermediate folders (linked) -->
                <li class="breadcrumb-item">
                    <a href="/data-cleaning-part-two/Orders-OrderItems-Payments">Orders orderitems payments</a>
                </li>
            
        
            
            
                <!-- Current page (active, no link) -->
                <li class="breadcrumb-item active" aria-current="page">Index.md</li>
            
        
    </ol>
</nav>


    <!-- Header Section -->
    <header class="bg-dark text-white text-center py-3">
       <h1>Target E-Commerce Revenue Analysis</h1>
    </header>  

    <!-- Main Content -->
    <main class="container my-4">
        <h1 id="orders_final-order_items_final-and-payments_final-overview">Orders_Final, Order_Items_Final, and Payments_Final Overview</h1>

<h2 id="overviews-of-table-changes">Overviews of Table Changes</h2>

<p><strong>To see an overview of changes made to each table, click the respective link below:</strong></p>

<ul>
  <li><a href="./Orders_Final/index.md">Orders_Final</a></li>
  <li><a href="./Order_Items_Final/index.md">Order_Items_Final</a></li>
  <li><a href="./Payments_Final/index.md">Payments_Final</a></li>
</ul>

<hr />

<p>The <code class="language-plaintext highlighter-rouge">Orders_Final</code>, <code class="language-plaintext highlighter-rouge">Order_Items_Final</code>, and <code class="language-plaintext highlighter-rouge">Payments_Final</code> tables are connected through shared <code class="language-plaintext highlighter-rouge">order_id</code>s. The <code class="language-plaintext highlighter-rouge">Order_Items_Final</code> table contains <code class="language-plaintext highlighter-rouge">price</code> and <code class="language-plaintext highlighter-rouge">freight_value</code> columns, which together should equal the <code class="language-plaintext highlighter-rouge">total_payment_value</code> in <code class="language-plaintext highlighter-rouge">Payments_Final</code>. In the initial phase of analysis, I discovered discrepancies in these calculations and removed them to maintain data accuracy.</p>

<p>Since then, the dataset has undergone significant improvements, with an increased number of validated <code class="language-plaintext highlighter-rouge">customer_id</code>s and verified location data. As a result, I recalculated the discrepancy function to ensure all identified issues were accurately addressed. Additionally, I removed the <code class="language-plaintext highlighter-rouge">payment_type</code> and <code class="language-plaintext highlighter-rouge">payment_installments</code> columns from <code class="language-plaintext highlighter-rouge">Payments_Final</code>, which had been causing duplicate <code class="language-plaintext highlighter-rouge">order_id</code>s and was likely a primary source of the original discrepancies. This iterative cleaning process not only resolved outstanding issues but also enabled a more precise reconciliation between <code class="language-plaintext highlighter-rouge">Orders_Final</code> and <code class="language-plaintext highlighter-rouge">Order_Items_Final</code>.</p>

<p>With these recalculations, the newly created <code class="language-plaintext highlighter-rouge">Recalculated_Missing_Orders</code> and <code class="language-plaintext highlighter-rouge">Recalculated_Discrepant_Orders</code> tables now accurately reflect missing and discrepant <code class="language-plaintext highlighter-rouge">order_id</code>s, strengthening data integrity and providing a solid foundation for revenue analysis. These adjustments will ensure consistent calculations of total revenue and profitability across product categories, seller regions, and customer demographics.</p>

<hr />
<h2 id="recalculated_discrepant_orders-table"><code class="language-plaintext highlighter-rouge">Recalculated_Discrepant_Orders</code> Table</h2>
<p>To generate an updated list of <code class="language-plaintext highlighter-rouge">order_id</code>s with discrepancies between expected total payment values and calculated total order values, I created two temporary tables and joined them. Using <code class="language-plaintext highlighter-rouge">ROUND(SUM(...), 2)</code> alone would have helped to remove some small discrepancies, but others still would have appeared due to precision limitations. Including <code class="language-plaintext highlighter-rouge">AND ABS(c.calculated_order_value - p.total_payment_value) &gt;= 0.01</code> ensured that only <code class="language-plaintext highlighter-rouge">order_id</code>s with discrepancies of at least a penny were flagged accounting for the precision limitations of the <code class="language-plaintext highlighter-rouge">ROUND</code> function.</p>

<details>
<summary>
üîç <b><i>Expand to View Details on the Creation of Recalculated_Discrepant_Orders</i></b>
</summary>
<br />

<pre><code class="language-sql">
/* 
    This query recalculates discrepant orders now that Payments_Final has removed payment types, eliminating duplicate order_ids in the table. 
    Two temporary tables are created and then joined to find discrepancies between total_payment_values in Payments_Final and 
    calculated_order_values based on price and freight_value in Order_Items_Final. In the JOIN, these two values are subtracted, 
    and only order_ids with calculated discrepancies of at least 0.01 (at least a penny) are displayed.
*/

CREATE OR REPlACE TABLE iconic-fountain-435918-q3.Target_Ecommerce_Sales_2016_2018.Recalculated_Discrepant_Orders AS(
    -- Create a temporary table to calculate the total value per order_id from Order_Items_Final
    WITH Calculated_Order_Values AS (
    SELECT 
        order_id,
        ROUND(SUM(price + freight_value),2) AS calculated_order_value
    FROM 
        iconic-fountain-435918-q3.Target_Ecommerce_Sales_2016_2018.Order_Items_Final
    GROUP BY 
        order_id
    ),

    -- Create a temporary table to get the total payment value per order_id from Payments_Final
    Payments_Total AS (
        SELECT 
            order_id,
            ROUND(SUM(total_payment_value),3) AS total_payment_value
        FROM 
            iconic-fountain-435918-q3.Target_Ecommerce_Sales_2016_2018.Payments_Final
        GROUP BY 
            order_id
    )

    -- Join the calculated and actual payment values to identify discrepancies
    SELECT 
        c.order_id,
        c.calculated_order_value,
        p.total_payment_value,
        -- Calculate the difference for easy identification of discrepancies
        c.calculated_order_value - p.total_payment_value AS discrepancy
    FROM 
        Calculated_Order_Values AS c
    INNER JOIN 
        Payments_Total AS p
    ON 
        c.order_id = p.order_id
    WHERE 
        c.calculated_order_value != p.total_payment_value
        AND ABS(c.calculated_order_value - p.total_payment_value) &gt;= 0.01 --Ensures discrepancies are at least a penny
);
</code></pre>

This query yielded **351** `order_id`s. 

</details>

<hr />

<h2 id="recalculated_missing_orders-table"><code class="language-plaintext highlighter-rouge">Recalculated_Missing_Orders</code> Table</h2>

<p>In addition to these discrepant <code class="language-plaintext highlighter-rouge">order_id</code>s, there are also several <code class="language-plaintext highlighter-rouge">order_id</code>s that appear in <code class="language-plaintext highlighter-rouge">Orders</code> but do not appear in <code class="language-plaintext highlighter-rouge">Order Items</code>. If left unaddressed, this would create discrepancies in analysis between <code class="language-plaintext highlighter-rouge">Orders_Final</code> and <code class="language-plaintext highlighter-rouge">Order_Items_Final</code>. During my initial data cleaning and analysis, I identified a list of these missing <code class="language-plaintext highlighter-rouge">order_id</code>s, primarily due to certain <code class="language-plaintext highlighter-rouge">order_id</code>s having a status of ‚Äúunavailable‚Äù or ‚Äúcanceled,‚Äù with a few others under different statuses.</p>

<p>I downloaded this list as a .CSV file and imported it into Google BigQuery to filter <code class="language-plaintext highlighter-rouge">Orders_Final</code> and <code class="language-plaintext highlighter-rouge">Order_Items_Final</code> and ensure no missing <code class="language-plaintext highlighter-rouge">order_id</code>s remained. However, after an increase in verified <code class="language-plaintext highlighter-rouge">customer_id</code>s, I realized I needed to recalculate the missing orders to maintain data consistency.</p>

<details>
<summary>üîç <b><i>Expand to View Details on the Creation of Recalculated_Missing_Orders</i></b></summary>
    
<h3>Step 1: Calculate Missing `order_id`s by Status</h3>

<p>First, I needed to find out how many missing `order_id`s there were along with a breakdown per status.</p>

<details>
<summary>üìÇ<b><i>Query to Find Missing order_ids by their status</i></b></summary>

<pre><code class="language-sql">
  /*
    This query creates a temporary table (MissingOrderIDs) to calculate the count of missing order_ids for each order_status.
    It then selects the order_status and total_missing_order_ids from the temp table and adds a "Total" row,
    which sums up total_missing_order_ids across all statuses using a UNION ALL statement.
  */
  
  
  WITH MissingOrderIDs AS (
      SELECT 
          o.order_status,
          COUNT(o.order_id) AS total_missing_order_ids
      FROM iconic-fountain-435918-q3.Target_Ecommerce_Sales_2016_2018.Orders_Final o
      LEFT JOIN iconic-fountain-435918-q3.Target_Ecommerce_Sales_2016_2018.Order_Items_Final oi ON o.order_id = oi.order_id
      WHERE oi.order_id IS NULL
      GROUP BY o.order_status
  )
  
  SELECT 
    order_status, 
    total_missing_order_ids
  FROM 
    MissingOrderIDs
  
  UNION ALL
  
  SELECT 
    'Total' AS order_status, SUM(total_missing_order_ids) AS total_missing_order_ids
  FROM 
    MissingOrderIDs;
</code></pre>   

</details>

**Supporting Table:**

<details>
<summary>üìã <b>Table 1: Missing `order_id`s by Status</b></summary>
    

    
  ![Table of `order_status` and accompanying `total_missing_order_ids`](https://github.com/user-attachments/assets/70f42426-fc5c-4d90-a01c-40bd00a68836)


  - As you can see, there are 733 total missing `order_id`s now, the majority of which contain the status `unavailable`.
    
</details>


<h3>Step 2: Verify Total Missing `order_id`s</h3>

<p>To confirm that this total was accurate, I compared the distinct order_id counts between `Orders_Final` and `Order_Items_Final`:</p>

<details>
<summary>üìÇ<b><i>Query to Verify Number of Missing ids</i></b></summary>
    
<pre><code class="language-sql">
/* 
  This query finds the distinct number of order_ids from Orders_Final and Order_Items_Final to confirm the number of 
  missing order_ids
*/

SELECT 
    (SELECT COUNT(DISTINCT order_id) FROM iconic-fountain-435918-q3.Target_Ecommerce_Sales_2016_2018.Orders_Final) AS distinct_order_ids_orders,
    (SELECT COUNT(DISTINCT order_id) FROM iconic-fountain-435918-q3.Target_Ecommerce_Sales_2016_2018.Order_Items_Final) AS distinct_order_ids_order_items;

</code></pre>
    
</details>


<details>
<summary>üìã<b><i>Table 2: Distinct order_id Counts in Orders_Final and Order_Items_Final</i></b></summary>    

![Table of distinct `order_id` counts for each table](https://github.com/user-attachments/assets/f04c8379-f90b-4fde-9b18-0b0570e3e39b)


  - Subtracting the two totals confirms the 733 number that was calculated before.
 

</details>

- *Note: The [`Orders_Final`](Orders_Final/steps.md) and [`Order_Items_Final`](Order_Items_Final/steps.md) creation steps can be found in their respective steps.md files.*



<h3>Step 3: Created `Recalculated_Missing_Orders` Table</h3>

<p>To isolate the actual missing order_ids, I created a table called `Recalculated_Missing_Orders`:</p>

<details>
<summary>üìÇ<b><i>Query to create Recalculated_Missing_Orders</i></b></summary>

<pre><code class="language-sql">
/*
  This query creates a new table, Recalculated_Missing_Orders, containing order_ids that appear in Orders_Final
  but are missing in Order_Items_Final. The LEFT JOIN includes all order_ids from Orders_Final, and the WHERE clause
  filters specifically for those missing in Order_Items_Final (where oi.order_id is NULL).
*/

CREATE TABLE 
  iconic-fountain-435918-q3.Target_Ecommerce_Sales_2016_2018.Recalculated_Missing_Orders AS
SELECT 
  o.order_id, o.order_status
FROM 
  iconic-fountain-435918-q3.Target_Ecommerce_Sales_2016_2018.Orders_Final o
LEFT JOIN 
  iconic-fountain-435918-q3.Target_Ecommerce_Sales_2016_2018.Order_Items_Final oi 
ON 
  o.order_id = oi.order_id
WHERE 
  oi.order_id IS NULL;
</code></pre>
    
</details>



<h3>Step 4: Verify Equal Distinct `order_id`s

<p>After creating the final versions of `Orders_Final` and `Order_Items_Final`, I wanted to ensure that all missing or discrepant `order_id`s were properly excluded and that the number of distinct `order_id`s matched between the `Orders_Final` and `Order_Items_Final` tables.</p>

<details>
<summary>üìÇ<b><i>Query to Verify Successful Removal of Missing ids</i></b></summary>
    
<pre><code class="language-sql">
SELECT 
    (SELECT COUNT(DISTINCT order_id) FROM iconic-fountain-435918-q3.Target_Ecommerce_Sales_2016_2018.Orders_Final) AS distinct_order_ids_orders,
    (SELECT COUNT(DISTINCT order_id) FROM iconic-fountain-435918-q3.Target_Ecommerce_Sales_2016_2018.Order_Items_Final) AS distinct_order_ids_order_items;
</code></pre>
    
</details>

<details>
<summary>üìã<b><i>Table 3: Equal Distinct order_id Counts between Orders_Final and Order_Items_Final</i></b></summary>

![Table of distinct `order_id` counts for each table](https://github.com/user-attachments/assets/04c9e3ae-2da2-4d38-bd3f-8121f5fc2453)


- When the query confirmed equal counts for both tables, I knew the cleaning steps had been effective.    

</details>




*Note: One `order_id` was also missing in the `Payments_Final` table. The steps taken to identify and resolve this discrepancy are detailed in [Payments_Final steps.md](./Payments_Final/steps.md).*

&lt;/details&gt;

---

## Conclusion

By recalculating missing and discrepant `order_id`s, I refined the consistency between `Orders_Final`, `Order_Items_Final`, and `Payments_Final`, ensuring that all relevant `order_id`s were accounted for. Initially, missing `order_id`s posed a risk of revenue discrepancies, particularly for orders with "unavailable" or "canceled" statuses. After identifying and excluding these, I verified the updated total of **769 missing `order_id`s**.

In addition to addressing missing `order_id`s, I resolved discrepancies in payment values between `Order_Items_Final` and `Payments_Final`. These discrepancies arose from mismatches between calculated payment values (`price` + `freight_value`) in `Order_Items_Final` and the entered values in `Payments_Final`. 

To ensure accurate revenue analysis:
1. I excluded `order_id`s with discrepancies of at least a penny.
2. I removed the `payment_type` and `payment_installments` columns from `Payments_Final`, eliminating unnecessary duplicates caused by these fields.
3. I reinserted a missing `order_id`, as detailed in the steps documented in [Payments_Final steps.md](./Payments_Final/steps.md).

These changes resulted in a cleaner and more consistent `Payments_Final` table that aligns with `Order_Items_Final` and `Orders_Final`.

This recalculation process‚Äîaddressing both missing and discrepant `order_id`s‚Äîstrengthened data integrity and minimized revenue discrepancies. The removal of these `order_id`s, as documented in the `Recalculated_Missing_Orders` and `Recalculated_Discrepant_Orders` tables, provides a solid foundation for downstream analysis. Key metrics, such as total revenue and profitability across product categories and customer regions, are now more reliable, ensuring meaningful and accurate insights.




---
</h3></details>

    </main>

    <-- Footer -->
    <footer class="text-center text-muted py-3">
        &copy; 2024 Your Name. All rights reserved.<br>
        Dataset used in this project is provided by <a href="https://www.kaggle.com/devarajv88" target="_blank">Devaraj V</a> on <a href="https://www.kaggle.com/" target="_blank">Kaggle</a>.<br>
        This project is for educational and portfolio purposes only.
    </footer>


<script>
    // Dynamically add a "Copy" button to each <pre><code> block
    document.querySelectorAll("pre").forEach((pre) => {
        // Create the copy button container
        const button = document.createElement("button");
        button.className = "copy-button";
        button.onclick = () => copyCode(pre);

        // Add the icon inside the button
        const icon = document.createElement("i");
        icon.className = "copy-icon";
        button.appendChild(icon);

        // Position the button inside the code block
        pre.style.position = "relative"; // Ensure the button is positioned correctly
        pre.appendChild(button);
    });

    // Function to handle copying code
    function copyCode(pre) {
        const codeBlock = pre.querySelector("code");
        if (!codeBlock) return;

        // Copy the code content
        navigator.clipboard.writeText(codeBlock.textContent).then(() => {
            // Change the icon to indicate success temporarily
            const icon = pre.querySelector(".copy-icon");
            icon.classList.add("copied");
            setTimeout(() => icon.classList.remove("copied"), 2000);
        }).catch((err) => {
            console.error("Failed to copy: ", err);
        });
    }
</script>




</body>
</html>
