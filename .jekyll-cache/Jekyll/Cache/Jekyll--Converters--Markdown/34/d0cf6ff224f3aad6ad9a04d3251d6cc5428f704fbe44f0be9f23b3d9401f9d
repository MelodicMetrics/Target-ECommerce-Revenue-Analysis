I"›><h1 id="geolocation_final-table-creation-steps">Geolocation_Final Table Creation Steps</h1>

<p><br /></p>

<h2 id="part-1-dataset-download">Part 1. Dataset Download</h2>

<ul>
  <li>After downloading the dataset from the IBGE, I translated each column title to English in order to determine which columns were most likely to contain the information I was looking for <em>(cities and states)</em>.</li>
  <li>After determining which columns I needed (Name of Municipality for Cities and Name of Federative Unit for States), I copied them into a new sheet and created a table (<code class="language-plaintext highlighter-rouge">City_State_Cleaning</code>).</li>
</ul>

<h2 id="part-2-dataset-cleaning">Part 2. Dataset Cleaning</h2>

<p><br /></p>

<h4 id="step-1-convert-name-of-the-federative-unit-to-state-codeas-the-original-dataset-used-state-codes-rather-than-the-actual-state-federative-unit-names-i-had-to-convert-the-names-into-state-codes-in-order-to-do-this-i-created-a-separate-sheet-with-every-state-name-and-their-respective-state-code">Step 1. Convert <code class="language-plaintext highlighter-rouge">Name of the Federative Unit</code> to <code>State Code</code>As the original dataset used State Codes rather than the actual State (Federative Unit) names, I had to convert the names into State Codes. In order to do this, I created a separate sheet with every State name and their respective State Code.</h4>

<ul>
  <li>In my (<code class="language-plaintext highlighter-rouge">City_State_Cleaning</code>) table, I added a column entitled <strong>‚ÄúStateCode‚Äù</strong> and used the following function to find the proper State Code for each State:</li>
</ul>

<details>
 <summary>üìÇ<b><i>Formula to find matching State Code for each Federative Unit</i></b></summary>
<br />

 <pre><code class="language-plaintext">
 =XLOOKUP([@[Name of the Federative Unit]], StateCodes!A:A, StateCodes!B:B, "Not Found")
 </code></pre>
<br /> 
Where:
- `Name of the Federative Unit` refers to the column containing each state name.
- `StateCodes!` tells the XLOOKUP function to specifically look at columns in a different sheet entitled "StateCodes".
</details>

<hr />

<h4 id="step-2-convert-city-names-to-lowercase">Step 2: Convert City Names to Lowercase</h4>

<p>Next I needed to ensure that each city name was in lowercase to standardize with the original dataset.</p>

<ul>
  <li>I created a column entitled <strong>‚ÄúLowercase City‚Äù</strong> and used the following function to make every city name lowercase:</li>
</ul>

<details>
 <summary>üìÇ<b><i>Formula to Convert Every City Name to Lowecase</i></b></summary>
 <br />

<pre><code class="language-plaintext">
=LOWER([@[Name of Municipality(City)]])
</code></pre>
<br />

Where:

- `LOWER` is the function name that will return whatever value selected in lowercase.
- `Name of Municipality(City)` refers to the column containing the city names
</details>

<hr />

<h4 id="step-3-remove-accents-from-city-names">Step 3: Remove Accents from City Names</h4>

<p>My final step was to make sure that all of the cities did not contain accents due to most entries in the original dataset also not containing them.</p>

<ul>
  <li>I first copied all the cells in my <strong>‚ÄúLowercase City‚Äù</strong> column into another column entitled <strong>‚ÄúUnaccented City‚Äù</strong>. Then I pulled that column into Power Query.</li>
  <li>Once in Power Query I added the following step in advanced edit so that the m code looked like the following:</li>
</ul>

<details>
 <summary>üìÇ<b><i>M Code to remove Accents from City Names</i></b></summary>
<br />



<pre><code class="language-dax">
/*
  This long line of code basically just replaces all accents with their unaccented counterparts one by one
  while also ensuring any uppercase variants become lowercase as well.
*/

let
  #"Remove Accents" = Table.TransformColumns(
  #"Changed Type",
    {{"Unaccented City", each 
       Text.Replace(Text.Replace(Text.Replace(Text.Replace(Text.Replace(
       Text.Replace(Text.Replace(Text.Replace(Text.Replace(Text.Replace(
       Text.Replace(Text.Replace(Text.Replace(Text.Replace(Text.Replace(
       Text.Replace(Text.Replace(Text.Replace(Text.Replace(Text.Replace(
       Text.Replace(Text.Replace(Text.Replace(Text.Replace(Text.Replace(Text.Lower(_), "√°", "a"), "√†", "a"), 
       "√¢", "a"), "√§", "a"), "√£", "a"), "√•", "a"), 
       "√©", "e"), "√®", "e"), "√™", "e"), "√´", "e"),
       "√≠", "i"), "√¨", "i"), "√Æ", "i"), "√Ø", "i"), 
       "√≥", "o"), "√≤", "o"), "√¥", "o"), "√∂", "o"), "√µ", "o"), 
       "√∫", "u"), "√π", "u"), "√ª", "u"), "√º", "u"), 
       "√±", "n"), "√ß", "c")}}
  )
 in
  #"Remove Accents"
</code></pre>



</details>

<hr />

<h4 id="step-4-remove-duplicate-cities">Step 4: Remove Duplicate Cities</h4>

<p>After cleaning the city names and converting the states into State Codes, I needed to account for any potential duplicated cities. The original dataset was more granular and included detailed disricts and administrative divisions per city. I was able to accomplish this task by highlighting my list of cities and using the <code class="language-plaintext highlighter-rouge">Remove Duplicates</code> function in Excel.</p>

<ul>
  <li>This gave me a cleaned table and so I copied the ‚ÄúStateCode‚Äù and ‚ÄúUnaccented City‚Äù columns to a final sheet entitled <em>‚ÄúIBGE Brazil City States‚Äù</em>. This table I saved as a .csv <code class="language-plaintext highlighter-rouge">IBGE_City_State_Source_of_Truth</code>, which I imported into Google BigQuery under the same name.</li>
</ul>

<hr />

<h2 id="part-3-geolocation_final-creation">Part 3. Geolocation_Final Creation</h2>

<p><br /></p>

<h4 id="objective">Objective:</h4>

<p>After creating the table in BigQuery, I needed to filter the <code class="language-plaintext highlighter-rouge">Geolocation</code> table to only display cities and states that were marked as valid by my <code class="language-plaintext highlighter-rouge">IBGE_City_State_Source_of_Truth</code> table. In order to do so, I needed to complete the following steps.</p>

<p><strong>1.</strong> I needed to make sure that none of the cities in the original <code class="language-plaintext highlighter-rouge">Geolocation</code> table contained accents due to data entry errors.</p>

<p><strong>2.</strong> Join that unaccented <code class="language-plaintext highlighter-rouge">Geolocation</code> table with <code class="language-plaintext highlighter-rouge">IBGE_City_State_Source_of_Truth</code>.</p>

<details>
<summary>üîç <b><i>Expand to view the steps in creating Geolocation_Final</i></b> </summary>
<br />

<h3>Step 1: Creating <code>Geolocation_Unaccented</code></h3>

- I wrote the following query in order to create a new table of geolocations that ensured all cities were unaccented:

<br /> 
<br />
 <details>
   <summary>üìÇ<b><i>Query to remove all accents from original Geolocation table</i></b></summary>
<br />

<pre><code class="language-sql">
   /*
    This query creates a new table called Gelocation_Unaccented where all the cities from the original table are unaccented.
    LOWER(...) converts all the city names to lowercase for consistent comparison. REGEXP_REPLACE(...) replaces all the accented characters with their unaccented versions.
    The original geolocation_city column is retained as well for reference.
    */
     CREATE OR REPLACE TABLE `iconic-fountain-435918-q3.Target_Ecommerce_Sales_2016_2018.Geolocation_Unaccented` AS
    SELECT
    geolocation_state,
    LOWER(
        REGEXP_REPLACE(
                    REGEXP_REPLACE(
                        REGEXP_REPLACE(
                            REGEXP_REPLACE(
                                REGEXP_REPLACE(
                                    REGEXP_REPLACE(
                                        REGEXP_REPLACE(
                                            REGEXP_REPLACE(
                                                REGEXP_REPLACE(
                                                    REGEXP_REPLACE(
                                                        REGEXP_REPLACE(
                                                            REGEXP_REPLACE(
                                                                REGEXP_REPLACE(
                                                                    REGEXP_REPLACE(
                                                                        geolocation_city,
                                                                        r"[√Å√Ä√Ç√Ñ√É]", "A"),
                                                                    r"[√°√†√¢√§√£]", "a"),
                                                                r"[√â√à√ä√ã]", "E"),
                                                            r"[√©√®√™√´]", "e"),
                                                        r"[√ç√å√é√è]", "I"),
                                                    r"[√≠√¨√Æ√Ø]", "i"),
                                                r"[√ì√í√î√ñ√ï]", "O"),
                                            r"[√≥√≤√¥√∂√µ]", "o"),
                                        r"[√ö√ô√õ√ú]", "U"),
                                    r"[√∫√π√ª√º]", "u"),
                                r"√ë", "N"),
                            r"√±", "n"),
                        r"√á", "C"),
                    r"√ß", "c")
            )
     AS geolocation_city_unaccented,
    geolocation_city AS original_geolocation_city  -- Retain the original column for reference
    FROM
    `iconic-fountain-435918-q3.Target_Ecommerce_Sales_2016_2018.Geolocation`
</code></pre>
 </details>
<br />

<h3>Step 2: Creating <code>Geolocation_Final</code> with a RIGHT JOIN</h3>
<br />

- Once <code>Geolocation_Unaccented</code> was created, I proceed to create the <code>Geolocation_Final</code> table using a <code>RIGHT JOIN</code> to ensure all city-state combinations from <code>IBGE_City_State_Source_of_Truth</code> were included, even if they did not have a match in <code>Geolocation_Unaccented</code>.

<br />
<br />

 <details>
 <summary>üìÇ<b><i>Query to Create Geolocation_Final</i></b></summary>
<br />

<pre><code class="language-sql">
    /* 
    1.The COALESCE function is used to select values from Geolocation_Unaccented if it's present or default to values from IBGE_City_State_Source_of_Truth.
    This approach helps to fill in missing entries from the Geolocation_Unaccented table with data from the source of truth table.
    2. The RIGHT JOIN is used to include all rows from the IBGE_City_State_Source_of_Truth table, even when there aren't matches in Geolocation_Unaccented.
    */ 
    -- Create a comprehensive Geolocations_Final table using RIGHT JOIN to ensure all IBGE entries appear
     CREATE OR REPLACE TABLE iconic-fountain-435918-q3.Target_Ecommerce_Sales_2016_2018.Geolocation_Final AS
     SELECT DISTINCT
         COALESCE(geo.geolocation_city_unaccented, truth.city) AS city,
         COALESCE(geo.geolocation_state, truth.StateCode) AS state
     FROM     
         iconic-fountain-435918-q3.Target_Ecommerce_Sales_2016_2018.Geolocation_Unaccented AS geo
     RIGHT JOIN  
         iconic-fountain-435918-q3.Target_Ecommerce_Sales_2016_2018.IBGE_City_State_Source_of_Truth AS truth
     ON 
         truth.city = geo.geolocation_city_unaccented AND truth.StateCode = geo.geolocation_state;
</code></pre>
 </details>

</details>
<p><br /></p>

<p>üéØüéØüéØüéØüéØ
<br />
<br /></p>

<details>
<summary>üîç<b><i>Expand to view an explanation of why I used each function in the query</i></b></summary>

<h3> 3A. Why RIGHT JOIN? </h3>

<p>I noticed that when using an `INNER JOIN` to create the final table and selecting `DISTINCT` cities that were unaccented, I would get less customer_ids than if I used a `RIGHT JOIN` from the `IBGE_City_State_Source_of_Truth` table. Specifically from **(98,715)** to **(98,709)**, a loss of **6** IDs.</p>

<h4>1. Using <code>Geolocation_Comparison</code> to Identify Missing Matches </h4>
 <p> To identify the cause of these removed IDs, I created a `Geolocation_Comparison` table using a `RIGHT JOIN` and retained accents to control for any potential changes introduced by removing them. The purpose of the `RIGHT JOIN` was to ensure that all city-state combinations from the source of truth table would appear, regardless of whether there was a matching entry in the Geolocation table.</p>

 <details>
  <summary>üìÇ<b><i>Query to Create Geolocation_Comparison</i></b></summary>
<br />

<pre>&lt;/code class = "language-sql"&gt;
      CREATE OR REPLACE TABLE iconic-fountain-435918-q3.Target_Ecommerce_Sales_2016_2018.Geolocation_Comparison AS 
      SELECT DISTINCT
        truth.City AS City,
        truth.StateCode AS Statecode
      FROM 
        `iconic-fountain-435918-q3.Target_Ecommerce_Sales_2016_2018.Geolocation` AS geo
      RIGHT JOIN 
        `iconic-fountain-435918-q3.Target_Ecommerce_Sales_2016_2018.IBGE_City_State_Source_of_Truth` AS truth
      ON
        geo.geolocation_city = truth.city AND geo.geolocation_state = truth.StateCode
&lt;/code&gt;</pre>
 </details>
<br />

<h4>2. Direct Comparison with <code>Geolocation_Final</code></h4> 
 
 <p> This table (`Geolocation_Comparison`) was used to directly compare with a filtered version, specifically `Geolocation_Final_Original`. The <code>INNER JOIN</code> in `Geolocations_Final` pulls only cities and states that have a match between the two tables. Additionally, accents were not removed to confirm that any discrepancies were due solely to the difference between an `INNER JOIN` and a `RIGHT JOIN`, rather than any potential issues introduced by `Geolocation_Unccented`.</p>

 <details>
  <summary>üìÇ<b><i>Query to Create Geolocation_Final_Original</i></b></summary>
  
```sql
       CREATE OR REPLACE TABLE iconic-fountain-435918-q3.Target_Ecommerce_Sales_2016_2018.Geolocation_Final_Original AS 
       SELECT DISTINCT
         truth.City AS City,
         truth.StateCode AS Statecode
       FROM 
         `iconic-fountain-435918-q3.Target_Ecommerce_Sales_2016_2018.Geolocation` AS geo
       INNER JOIN 
         `iconic-fountain-435918-q3.Target_Ecommerce_Sales_2016_2018.IBGE_City_State_Source_of_Truth` AS truth
       ON
         geo.geolocation_city = truth.city AND geo.geolocation_state = truth.StateCode
```  
 </details>
<br />

With these two versions of Geolocation tables, I could compare my customer tables to investigate why <code>INNER JOIN</code> was leading to fewer IDs. [Click here to read the steps taken in the `Customers_Final` folder](../Customers_Final/steps.md#3-comparison-of-customer-tables)
<br />
<br />

<p>
  <i>
    &bull; After running my comparison, I discovered that six cities in <code>Customer</code> were either misspelled or missing entirely from <code>Geolocation</code>. Using an INNER JOIN would only include cities present in both <code>Geolocation</code> and <code>IBGE_City_State_Source_of_Truth</code>. Therefore, to ensure these six cities were included, a <code>RIGHT JOIN</code> on <code>IBGE_City_State_Source_of_Truth</code> was the best choice, as it retains all entries from that table, regardless of their presence in <code>Geolocation</code>.
  </i>
</p>

<h3> 3B. Why COALESCE? </h3>
 
<p> 
  The purpose of the <code>COALESCE</code> function is to select values from <code>Geolocation_Unaccented</code> when present, or to default to values from <code>IBGE_City_State_Source_of_Truth</code> when they are missing. This approach handles cases like <code>"Sambaiba, MA"</code> by filling gaps in <code>Geolocation_Unaccented</code> with the authoritative data from the IBGE table.   
</p> </details>

<p>&lt;/details&gt;</p>

<hr />

<h3 id="data-source">Data Source</h3>

<p>The dataset for Brazilian municipalities and federative units was obtained from the <strong>IBGE</strong> <em>(Brazilian Institute of Geography and Statistics)</em>. You can access the original dataset <a href="https://www.ibge.gov.br/geociencias/organizacao-do-territorio/estrutura-territorial/23701-divisao-territorial-brasileira.html?=&amp;t=downloads">here</a>.</p>
:ET